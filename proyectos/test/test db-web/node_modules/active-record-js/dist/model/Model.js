"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("../emitter/events");
const query_1 = require("../query");
const related_1 = require("./related");
const relations_1 = __importDefault(require("./stores/relations"));
const mixins_1 = require("../utils/mixins");
class Model {
    constructor(attributes = {}, exists = false) {
        // Mixin type definitions
        this.CREATED_AT = 'createdAt';
        this.UPDATED_AT = 'updatedAt';
        this.attributes = {};
        this.appends = [];
        this.changedAttributes = [];
        this.timestamps = true;
        this.id = null;
        this.exists = false;
        this.incrementing = true;
        this.primaryKey = 'id';
        this.fillAttributes(attributes, exists);
        this.applyRelations();
        this.exists = exists;
        if (exists) {
            this.id = attributes[this.primaryKey];
        }
        return new Proxy(this, {
            get: (object, property) => {
                if (object.isAttribute(property)) {
                    return object.getAttribute(property);
                }
                return object[property];
            },
            set: (object, property, value) => {
                object.setAttribute(property, value);
                return true;
            }
        });
    }
    static async all() {
        return new this().newModelQuery().get();
    }
    applyRelations() {
        relations_1.default.getRelations(this.constructor.name).forEach(relation => Object.defineProperty(this, `\$${relation}`, {
            get: async () => await this[relation]().get()
        }));
    }
    async delete() {
        new events_1.ModelDeleting(this).fire();
        if (this.exists) {
            await this.newModelQuery()
                .where(this.primaryKey, '=', this.attributes[this.primaryKey])
                .delete();
            new events_1.ModelDeleted(this).fire();
            return true;
        }
        return false;
    }
    equals(instance) {
        if (this.constructor['table'] === instance.constructor['table'] &&
            this.primaryKey === instance.primaryKey &&
            this[this.primaryKey] === instance[this.primaryKey]) {
            return true;
        }
        return false;
    }
    static async findById(id) {
        return new this().newModelQuery().setIsFirst(true).where('id', '=', id).get();
    }
    static async saveMany(rows) {
        return new this().newModelQuery().insertMany(rows);
    }
    newModelQuery() {
        return new query_1.Builder().setModel(this.constructor.name);
    }
    async performInsert(query) {
        const id = await query.insert(this.attributes);
        this.id = id;
        this.exists = true;
        new events_1.ModelCreated(this).fire();
        return true;
    }
    async performUpdate(query) {
        const success = await query.update(this.getDirtyAttributes());
        new events_1.ModelUpdated(this).fire();
        return success;
    }
    async save() {
        new events_1.ModelSaving(this).fire();
        let success = false;
        const query = this.newModelQuery();
        if (this.exists && this.isDirty()) {
            new events_1.ModelUpdating(this).fire();
            success = await this.performUpdate(query);
        }
        else if (this.isDirty()) {
            new events_1.ModelCreating(this).fire();
            success = await this.performInsert(query);
        }
        if (success) {
            this.clearChangedAttributes();
            new events_1.ModelSaved(this).fire();
        }
        return success;
    }
    static select(select) {
        return new this().newModelQuery().select(select);
    }
    toJSON() {
        return Object.keys(this.attributes)
            .filter(key => !this.getHidden().includes(key))
            .reduce((object, key) => {
            object[key] = this.attributes[key];
            return object;
        }, {});
    }
    static where(column, operator, value) {
        return new this().newModelQuery().where(column, operator, value);
    }
    static whereIn(column, value) {
        return new this().newModelQuery().whereIn(column, value);
    }
}
Model.casts = {};
Model.hidden = [];
// End mixin type definitions
Model.table = '';
mixins_1.applyMixins(Model, [related_1.HasAttributes, related_1.HasRelationships, related_1.HasTimestamps, related_1.HidesAttributes]);
exports.default = Model;
