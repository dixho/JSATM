"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const connection_1 = require("../connection");
const Pagination_1 = require("../libraries/Pagination");
const models_1 = __importDefault(require("../model/stores/models"));
const constants_1 = require("./constants");
const expressions_1 = require("./expressions");
const Compiler_1 = __importDefault(require("./Compiler"));
class Builder {
    constructor() {
        // The model class associated with this query. If there is a model class, it will be used to transform
        // returned row(s) into model instances
        this.model = '';
        // Select distinct
        this.isDistinct = false;
        // Limits the query to 1 and returns the first result if true
        this.isFirst = false;
        this.rawSelects = [];
        this.selects = [];
        // The base table of the query. All other tables are appended via joins
        this.fromTable = '';
        this.groups = [];
        this.havings = [];
        this.joins = [];
        this.orders = [];
        this.updates = {};
        this.wheres = [];
        this.compiler = new Compiler_1.default();
    }
    async count() {
        const sql = this.compiler.compileSelect(this, true);
        let rows = await connection_1.DB.run(sql);
        return rows[0].count;
    }
    async delete(attributes = {}) {
        for (const key in attributes) {
            this.where(key, '=', attributes[key]);
        }
        const sql = this.compiler.compileDelete(this);
        await connection_1.DB.run(sql);
    }
    distinct() {
        this.isDistinct = true;
        return this;
    }
    async first() {
        this.setIsFirst(true);
        return await this.get();
    }
    from(table) {
        this.fromTable = table;
        if (this.selects.length === 0) {
            this.selects.push(`${table}.*`);
        }
        return this;
    }
    async get() {
        const sql = this.compiler.compileSelect(this);
        let rows = await connection_1.DB.run(sql);
        rows = this.transformRows(rows);
        if (this.isFirst) {
            return rows.shift();
        }
        return rows;
    }
    groupBy(groups) {
        this.groups = groups;
        return this;
    }
    async insert(attributes) {
        const sql = this.compiler.compileInsert(this, [attributes]);
        const { insertId } = await connection_1.DB.run(sql);
        return insertId;
    }
    async insertMany(rows) {
        const sql = this.compiler.compileInsert(this, rows);
        const result = await connection_1.DB.run(sql);
        return result;
    }
    join(table, localKey, operator, foreignKey) {
        this.joins.push(new expressions_1.Join(table, localKey, operator, foreignKey, constants_1.JoinType.Inner));
        return this;
    }
    leftJoin(table, localKey, operator, foreignKey) {
        this.joins.push(new expressions_1.Join(table, localKey, operator, foreignKey, constants_1.JoinType.Left));
        return this;
    }
    limit(limit) {
        if (!Number.isInteger(limit)) {
            throw `Limit must be an integer: ${limit}`;
        }
        this.limits = limit;
        return this;
    }
    setModel(model) {
        this.model = model;
        this.from(models_1.default.getModel(model).table);
        return this;
    }
    offset(offset) {
        if (!Number.isInteger(offset)) {
            throw `Offset must be an integer: ${offset}`;
        }
        this.offsets = offset;
        return this;
    }
    orderBy(column, direction) {
        this.orders.push(new expressions_1.Order(column, direction));
        return this;
    }
    orWhere(column, operator, value) {
        this.wheres.push(new expressions_1.Where(column, operator, value, expressions_1.Where.conditions.OR));
        return this;
    }
    async paginate(options) {
        const pagination = new Pagination_1.Pagination(Object.assign({ query: this }, options));
        return await pagination.paginate();
    }
    rightJoin(table, localKey, operator, foreignKey) {
        this.joins.push(new expressions_1.Join(table, localKey, operator, foreignKey, constants_1.JoinType.Right));
        return this;
    }
    select(selects) {
        this.selects = selects.slice();
        return this;
    }
    setIsFirst(isFirst) {
        this.isFirst = isFirst;
        if (isFirst) {
            this.limit(1);
        }
        return this;
    }
    toSql() {
        return this.compiler.compileSelect(this);
    }
    transformRows(rows) {
        if (!this.model) {
            return rows;
        }
        const Model = models_1.default.getModel(this.model);
        return rows.map(row => new Model(row, true));
    }
    async update(updates) {
        const sql = this.compiler.compileUpdate(this, updates);
        return await connection_1.DB.run(sql);
    }
    where(column, operator, value) {
        this.wheres.push(new expressions_1.Where(column, operator, value, expressions_1.Where.conditions.AND));
        return this;
    }
    whereIn(column, value) {
        this.wheres.push(new expressions_1.Where(column, 'in', value, expressions_1.Where.conditions.AND));
        return this;
    }
}
exports.default = Builder;
